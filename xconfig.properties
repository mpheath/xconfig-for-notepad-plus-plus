## Many properties and descriptions thanks to Neil Hodgson at scintilla.org
## Only 1 line of description before the property named key
## Descriptions should start with 1 hash symbol and a space
## Section names display in a ui label and should be on a line of their own


[editor]
## Scintilla related properties

# If backspace.unindents is 1 then pressing backspace within indentation whitespace unindents by indent.size rather than deleting the character before the caret.
backspace.unindents=

# Colour of bookmark symbol. Must be 6 RGB hexadecimal characters. The blue orb symbol is a piximap so colour may have no effect on it. Default: FFFFFF (White).
bookmark.colour=

# The visual style used to display bookmarks in the margin. Set to a numeric value according to the symbols defined in SCI_MARKERDEFINE. Symbols: 0-34.
bookmark.marker=

# Sets the width of the caret in pixels. Max width might vary on DPI setting...? Width: 1-20.
caret.width=

# The change.history property controls whether changes to the document (insertions, deletions, saved changes, ...) are shown as margin markers or indicators within text. 1 None. 3 Markers. 5 Indicators. 7 Markers and Indicators.
change.history=

# Indicators for change.history. See https://scintilla.org/ScintillaDoc.html#SCI_INDICSETSTYLE for values. Some values are 0 INDIC_PLAIN, 6 INDIC_BOX, 7 INDIC_ROUNDBOX, 16 INDIC_FULLBOX and 21 INDIC_GRADIENTCENTRE. Indicators: 0-22.
change.history.indicator=

# Colour of modified change.history. Must be 6 RGB hexadecimal characters. Default: FF8000 (Orange).
change.history.colour.modified=

# Colour of reverted to modified change.history. Must be 6 RGB hexadecimal characters. Default: A0C000 (Lime).
change.history.colour.reverted.modified=

# Colour of reverted to origin change.history. Must be 6 RGB hexadecimal characters. Default: 40A0BF (Blue).
change.history.colour.reverted.origin=

# Colour of saved change.history. Must be 6 RGB hexadecimal characters. Default: 00A000 (Green).
change.history.colour.saved=

# Symbol of modified marker. Default: 33 (Orange bar). Symbols: 0-33.
change.history.marker.modified=

# Symbol of reverted to modified marker. Default: 33 (Lime bar). Symbols: 0-33.
change.history.marker.reverted.modified=

# Symbol of reverted to origin marker. Default: 33 (Blue bar). Symbols: 0-33.
change.history.marker.reverted.origin=

# Symbol of saved marker. Default: 33 (Green bar). Symbols: 0-33.
change.history.marker.saved=

# horizontal.scroll.width is the document width assumed for scrolling.
horizontal.scroll.width=

# The horizontal scroll bar widths can automatically grow as needed to ensure all displayed lines can be fully scrolled. 0 disable, 1 enable.
horizontal.scroll.width.tracking=

# On Windows Vista or newer, this can be set to 1, 2 or 3 to use the Direct2D and DirectWrite APIs for higher quality antialiased drawing or 0 to use the older GDI. The value 2 causes the frame to be retained after presentation which may prevent drawing failures on some cards and drivers. 3 may also prevent drawing failures on some cards and drivers but with lower speed.
technology=

# Sets the size used for displaying all visible spaces, especially for when whitespace.fore is set to be subtle.
whitespace.size=

# Choose between 0 no wrapping, 1 word wrapping (default), 2 character wrapping and 3 whitespace wrapping. Character wrapping is a better choice for Asian languages with no spaces between words.
wrap.style=

# Wrapped sublines can be indented in various ways relative to the initial subline. Default mode 0 indents sublines to the left of window plus wrap.visual.startindent. Mode 1 aligns sublines to the first subline. Mode 2 aligns sublines to the first subline plus one more level of indentation.
wrap.indent.mode=

# Flags to display markers at end and begin of wrapped lines for visual identify them. Set to 0 to not display markers (default). Set to 1 to display markers at end of wrapped lines, to 2 to display markers at begin of wrapped lines and to 3 to display markers at begin and end.
wrap.visual.flags=

# Flags to set the location of the display markers (if enabled) near to text or near to border. Set to 0 to have begin and end markers near to border (default). Set to 1 to have end markers near text, to 2 to have begin markers near text and to 3 to have all markers near text.
wrap.visual.flags.location=

# Sets the indention of continued wrapped lines to better visually identify the wrapping. Default is 0 (no indention). Note if wrap.visual.flags is 2 or 3 (begin marker displayed) the line is indented at least 1, even if wrap.visual.startindent is still 0.
wrap.visual.startindent=


[lexer]
## Lexilla related properties

# Folding is turned on by setting fold=1.
fold=

# For HTML, XML, Lua and C++ and similar files, turning this option on leads to blank lines following the end of an element folding with that element. Defaults to on.
fold.compact=

# Script in ASP code is initially assumed to be in JavaScript. To change this to VBScript set asp.default.language to 2. Python is 3.
asp.default.language=

# Set this property to 0 to disable folding multi-line comments when fold.comment=1.
fold.abl.comment.multiline=

# Set this property to 0 to disable syntax based folding.
fold.abl.syntax.based=

# This option enables folding explicit fold points when using the Asm lexer. Explicit fold points allows adding extra folding by placing a ;{ comment at the start and a ;} at the end of a section that should fold.
fold.asm.comment.explicit=

# Set this property to 1 to enable folding multi-line comments.
fold.asm.comment.multiline=

# Set this property to 1 to enable explicit fold points anywhere, not just in line comments.
fold.asm.explicit.anywhere=

# The string to use for explicit fold end points, replacing the standard ;}.
fold.asm.explicit.end=

# The string to use for explicit fold start points, replacing the standard ;{.
fold.asm.explicit.start=

# Set this property to 0 to disable syntax based folding.
fold.asm.syntax.based=

# This option enables C++ folding on a "} else {" line of an if statement.
fold.at.else=

# Set this property to 1 to enable folding of inner levels of select statements.Disabled by default. case and if statements are also eligible
fold.baan.inner.level=

# Set this property to 0 to disable keywords based folding, which is folding based on for, if, on (case), repeat, select, while and fold ends based on endfor, endif, endcase, until, endselect, endwhile respectively.Also folds declarations which are grouped together.
fold.baan.keywords.based=

# Set this property to 0 to disable folding of Main Sections as well as Sub Sections.
fold.baan.sections=

# Set this property to 0 to disable syntax based folding, which is folding based on '{' & '('.
fold.baan.syntax.based=

# This option enables folding explicit fold points when using the Basic lexer. Explicit fold points allows adding extra folding by placing a ;{ (BB/PB) or '{ (FB) comment at the start and a ;} (BB/PB) or '} (FB) at the end of a section that should be folded.
fold.basic.comment.explicit=

# Set this property to 1 to enable explicit fold points anywhere, not just in line comments.
fold.basic.explicit.anywhere=

# The string to use for explicit fold end points, replacing the standard ;} (BB/PB) or '} (FB).
fold.basic.explicit.end=

# The string to use for explicit fold start points, replacing the standard ;{ (BB/PB) or '{ (FB).
fold.basic.explicit.start=

# Set this property to 0 to disable syntax based folding.
fold.basic.syntax.based=

# Set this property to 0 to disable folding multi-line comments when fold.comment=1.
fold.cil.comment.multiline=

# Set to 1 to allow folding of comment blocks in CoffeeScript.
fold.coffeescript.comment=

# This option enables folding multi-line comments and explicit fold points when using the C++ lexer. Explicit fold points allows adding extra folding by placing a //{ comment at the start and a //} at the end of a section that should fold.
fold.comment=

# Set to 1 to allow folding of comment blocks in YAML.
fold.comment.yaml=

# Set this property to 0 to disable folding explicit fold points when fold.comment=1.
fold.cpp.comment.explicit=

# Set this property to 0 to disable folding multi-line comments when fold.comment=1.
fold.cpp.comment.multiline=

# Set this property to 1 to enable explicit fold points anywhere, not just in line comments.
fold.cpp.explicit.anywhere=

# The string to use for explicit fold end points, replacing the standard //}.
fold.cpp.explicit.end=

# The string to use for explicit fold start points, replacing the standard //{.
fold.cpp.explicit.start=

# This option enables folding on a preprocessor #else or #endif line of an #if statement.
fold.cpp.preprocessor.at.else=

# Set this property to 0 to disable syntax based folding.
fold.cpp.syntax.based=

# Set this property to 0 to disable folding explicit fold points when fold.comment=1.
fold.d.comment.explicit=

# Set this property to 0 to disable folding multi-line comments when fold.comment=1.
fold.d.comment.multiline=

# Set this property to 1 to enable explicit fold points anywhere, not just in line comments.
fold.d.explicit.anywhere=

# The string to use for explicit fold end points, replacing the standard //}.
fold.d.explicit.end=

# The string to use for explicit fold start points, replacing the standard //{.
fold.d.explicit.start=

# Set this property to 0 to disable syntax based folding.
fold.d.syntax.based=

# Set to 1 for enabling the code folding feature in *.prn files
fold.dataflex.compilerlist=

# Setting this option to 0 disables folding of grouped line comments in F# files when fold.comment=1.
fold.fsharp.comment.multiline=

# Setting this option to 0 disables folding of ML-style comments in F# files when fold.comment=1.
fold.fsharp.comment.stream=

# Setting this option to 0 disables folding of F# import declarations.
fold.fsharp.imports=

# Setting this option to 1 enables folding of F# compiler directives.
fold.fsharp.preprocessor=

# This option enables folding multi-line quoted strings when using the GDScript lexer.
fold.gdscript.quotes=

# Set to 1 to enable folding of import declarations
fold.haskell.imports=

# Folding is turned on or off for HTML and XML files with this option. The fold option must also be on for folding to occur.
fold.html=

# Folding is turned on or off for scripts embedded in HTML files with this option. The default is on.
fold.html.preprocessor=

# Allow folding for comments in scripts embedded in HTML. The default is off.
fold.hypertext.comment=

# Allow folding for heredocs in scripts embedded in HTML. The default is off.
fold.hypertext.heredoc=

# Fold multiline triple-doublequote strings, usually used to document a function or type above the definition.
fold.julia.docstring=

# Set this property to 0 to disable syntax based folding.
fold.julia.syntax.based=

# This option enables Perl folding on a "} else {" line of an if statement.
fold.perl.at.else=

# Set to 0 to disable explicit folding.
fold.perl.comment.explicit=

# Set to 0 to disable folding packages when using the Perl lexer.
fold.perl.package=

# Set to 0 to disable folding Pod blocks when using the Perl lexer.
fold.perl.pod=

# This option enables folding preprocessor directives when using the C++ lexer. Includes C#'s explicit #region and #endregion folding directives.
fold.preprocessor=

# This option enables folding multi-line quoted strings when using the Python lexer.
fold.quotes.python=

# Set this property to 0 to disable folding multi-line comments when fold.comment=1.
fold.raku.comment.multiline=

# Set this property to 0 to disable folding POD comments when fold.comment=1.
fold.raku.comment.pod=

# Set this property to 0 to disable folding explicit fold points when fold.comment=1.
fold.rust.comment.explicit=

# Set this property to 0 to disable folding multi-line comments when fold.comment=1.
fold.rust.comment.multiline=

# Set this property to 1 to enable explicit fold points anywhere, not just in line comments.
fold.rust.explicit.anywhere=

# The string to use for explicit fold end points, replacing the standard //}.
fold.rust.explicit.end=

# The string to use for explicit fold start points, replacing the standard //{.
fold.rust.explicit.start=

# Set this property to 0 to disable syntax based folding.
fold.rust.syntax.based=

# This option enables SQL folding on a "ELSE" and "ELSIF" line of an IF statement.
fold.sql.at.else=

# Set to 1 to only fold on 'begin' but not other keywords.
fold.sql.only.begin=

# This option enables folding module definitions. Typically source files contain only one module definition so this option is somewhat useless.
fold.verilog.flags=

# Enable folding for XML at the start of open tag. The default is off.
fold.xml.at.tag.open=

# For XML and HTML, setting this property to 1 will make tags match in a case sensitive way which is the expected behaviour for XML and XHTML.
html.tags.case.sensitive=

# Overrides the default comment character (which is ';' for asm and '#' for as).
lexer.as.comment.character=

# Character used for COMMENT directive's delimiter, replacing the standard "~".
lexer.asm.comment.delimiter=

# For Baan code, determines whether all preprocessor code is styled in the preprocessor style (0, the default) or only from the initial # to the end of the command word(1).
lexer.baan.styling.within.preprocessor=

# Set how to highlight $() command substitution. 0 (the default) highlighted as backticks. 1 highlighted inside. 2 highlighted inside with extra scope tracking.
lexer.bash.command.substitution=

# Set this property to 0 to disable nested backquoted command substitution.
lexer.bash.nested.backticks=

# Set shell (default is Bash) special parameters.
lexer.bash.special.parameter=

# Set this property to 1 to highlight shell expansions inside backticks.
lexer.bash.styling.inside.backticks=

# Set this property to 1 to highlight shell expansions inside here document.
lexer.bash.styling.inside.heredoc=

# Set this property to 1 to highlight shell expansions inside ${} parameter expansion.
lexer.bash.styling.inside.parameter=

# Set this property to 1 to highlight shell expansions inside string.
lexer.bash.styling.inside.string=

# Set to 0 to disallow the '$' character in identifiers with the cpp lexer.
lexer.cpp.allow.dollars=

# Set to 1 to enable highlighting of back-quoted raw strings.
lexer.cpp.backquoted.strings=

# Set to 1 to enable highlighting of escape sequences in strings
lexer.cpp.escape.sequence=

# Set to 1 to enable highlighting of hash-quoted strings.
lexer.cpp.hashquoted.strings=

# Set to 1 to interpret #if/#else/#endif to grey out code that is not active.
lexer.cpp.track.preprocessor=

# Set to 1 to enable highlighting of triple-quoted strings.
lexer.cpp.triplequoted.strings=

# Set to 1 to update preprocessor definitions when #define found.
lexer.cpp.update.preprocessor=

# Set to 1 to allow verbatim strings to contain escape sequences.
lexer.cpp.verbatim.strings.allow.escapes=

# Set to 1 for HSS (.hss)
lexer.css.hss.language=

# Set to 1 for Less CSS (.less)
lexer.css.less.language=

# Set to 1 for Sassy CSS (.scss)
lexer.css.scss.language=

# This option enables D folding on a "} else {" line of an if statement.
lexer.d.fold.at.else=

# Set to 0 to highlight only UNA segments, or 1 to highlight all UNx segments.
lexer.edifact.highlight.un.all=

# Set to 1 to interpret escape sequences.
lexer.errorlist.escape.sequences=

# For lines in the output pane that are matches from Find in Files or GCC-style diagnostics, style the path and line number separately from the rest of the line with style 21 used for the rest of the line. This allows matched text to be more easily distinguished from its location.
lexer.errorlist.value.separate=

# For Harbour code, determines whether all preprocessor code is styled in the preprocessor style (0) or only from the initial # to the end of the command word(1, the default). It also determines how to present text, dump, and disabled code.
lexer.flagship.styling.within.preprocessor=

# When enabled, it will not style keywords2 items that are used as a sub-identifier. Example: when set, will not highlight "foo.open" when "open" is a keywords2 item.
lexer.gdscript.keywords2.no.sub.identifiers=

# Set to 0 to not recognise binary and octal literals: 0b1011 0o712.
lexer.gdscript.literals.binary=

# Set to 1 to allow strings to span newline characters.
lexer.gdscript.strings.over.newline=

# Set to 0 to not recognise Unicode identifiers.
lexer.gdscript.unicode.identifiers=

# For GDScript code, checks whether indenting is consistent. The default, 0 turns off indentation checking, 1 checks whether each line is potentially inconsistent with the previous line, 2 checks whether any space characters occur before a tab character in the indentation, 3 checks whether any spaces are in the indentation, and 4 checks for any tab characters in the indentation. 1 is a good level to use.
lexer.gdscript.whinge.level=

# Set to 0 to disallow the '#' character at the end of identifiers and literals with the haskell lexer (GHC -XMagicHash extension)
lexer.haskell.allow.hash=

# Set to 1 to allow the '?' character at the start of identifiers with the haskell lexer (GHC & Hugs -XImplicitParams extension)
lexer.haskell.allow.questionmark=

# Set to 0 to disable highlighting of Template Haskell name quotations and promoted constructors (GHC -XTemplateHaskell and -XDataKinds extensions)
lexer.haskell.allow.quotes=

# Set to 0 to disable C-preprocessor highlighting (-XCPP extension)
lexer.haskell.cpp=

# Set to 0 to disallow "safe" keyword in imports (GHC -XSafe, -XTrustworthy, -XUnsafe extensions)
lexer.haskell.import.safe=

# Set to 1 to enable the django template language.
lexer.html.django=

# Set to 1 to enable the mako template language.
lexer.html.mako=

# Set to 1 to enable highlighting of line/block comments in JSON
lexer.json.allow.comments=

# Set to 1 to enable highlighting of escape sequences in strings
lexer.json.escape.sequence=

# This option enables highlighting of syntax error int character or number definition.
lexer.julia.highlight.lexerror=

# This option enables highlighting of the type identifier after `::`.
lexer.julia.highlight.typeannotation=

# Set to 1 to highlight all ATX header text.
lexer.markdown.header.eolfill=

# Set to 1 to enable highlighting generalized raw string identifiers. Generalized raw string identifiers are anything other than r (or R).
lexer.nim.raw.strings.highlight.ident=

# For properties files, set to 0 to style all lines that start with whitespace in the default style. This is not suitable for SciTE .properties files which use indentation for flow control but can be used for RFC2822 text where indentation is used for continuation lines.
lexer.props.allow.initial.spaces=

# Set to 1 to recognise Python decorator attributes.
lexer.python.decorator.attributes=

# Set to 1 to recognise Python identifier attributes.
lexer.python.identifier.attributes=

# When enabled, it will not style keywords2 items that are used as a sub-identifier. Example: when set, will not highlight "foo.open" when "open" is a keywords2 item.
lexer.python.keywords2.no.sub.identifiers=

# Set to 0 to not recognise Python 3 binary and octal literals: 0b1011 0o712.
lexer.python.literals.binary=

# Set to 0 to not recognise Python 3 bytes literals b"x".
lexer.python.strings.b=

# Set to 0 to not recognise Python 3.6 f-string literals f"var={var}".
lexer.python.strings.f=

# Set to 0 to use pre-PEP 701 / Python 3.12 f-string lexing.
lexer.python.strings.f.pep.701=

# Set to 1 to allow strings to span newline characters.
lexer.python.strings.over.newline=

# Set to 0 to not recognise Python Unicode literals u"x" as used before Python 3.
lexer.python.strings.u=

# Set to 0 to not recognise Python 3 Unicode identifiers.
lexer.python.unicode.identifiers=

# Set to 1 to enable highlighting of escape sequences in strings.
lexer.r.escape.sequence=

# This option enables Rust folding on a "} else {" line of an if statement.
lexer.rust.fold.at.else=

# Set to 1 to colourise recognized words with dots (recommended for Oracle PL/SQL objects).
lexer.sql.allow.dotted.word=

# Recognise backtick quoting of identifiers.
lexer.sql.backticks.identifier=

# If "lexer.sql.numbersign.comment" property is set to 0 a line beginning with '#' will not be a comment.
lexer.sql.numbersign.comment=

# Set to 1 to allow strings to continue over line ends.
lexer.vb.strings.multiline=

# Set to 1 to style identifiers that are all uppercase as documentation keyword.
lexer.verilog.allupperkeywords=

# This option enables folding on `else and `elsif preprocessor directives.
lexer.verilog.fold.preprocessor.else=

# Set to 1 to style input, output, and inout ports differently from regular keywords.
lexer.verilog.portstyling=

# Set to 1 to interpret `if/`else/`endif to grey out code that is not active.
lexer.verilog.track.preprocessor=

# Set to 1 to update preprocessor definitions when `define, `undef, or `undefineall found.
lexer.verilog.update.preprocessor=

# Set to 1 to enable using back quotes (``) to delimit strings.
lexer.visualprolog.backquoted.strings=

# Set to 0 to disable highlighting verbatim strings using '@'.
lexer.visualprolog.verbatim.strings=

# Set to 0 to disable scripts in XML.
lexer.xml.allow.scripts=

# Set to 1 to ignore case for NSIS.
nsis.ignorecase=

# Set to 1 to recognise user defined variables in NSIS.
nsis.uservars=

# Define level (0..3) of PostScript handled and thus set of keywords. Default is 3.
ps.level=

# Enables backslash as an escape character in SQL.
sql.backslash.escapes=

# For C++ code, determines whether all preprocessor code is styled in the preprocessor style (0, the default) or only from the initial # to the end of the command word(1).
styling.within.preprocessor=

# For Python code, checks whether indenting is consistent. The default, 0 turns off indentation checking, 1 checks whether each line is potentially inconsistent with the previous line, 2 checks whether any space characters occur before a tab character in the indentation, 3 checks whether any spaces are in the indentation, and 4 checks for any tab characters in the indentation. 1 is a good level to use.
tab.timmy.whinge.level=
